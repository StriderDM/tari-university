# Cryptographic Accumulators : A Distilled Introduction

## Background

The concept of Cryptographic accumulators were first introduced by Benaloh and de Mare, which was then further developed and formalized by BariÄ‡ and Pfitzmann. This became known as the RSA accumulator. Nguyen also contributed a new kind of accumulator (bilinear-map accumulators) which is based on elliptic curves and not modular exponentiation.

An accumulator is a one way hash function which works on a set. It takes a set of values
\(\{x_1,x_2,..., x_n\}\)
and accumulates it into a single constant value  of constant size \(z\). This is then used to verify if a value was a member of the original set or not, without revealing the original set, via a membership or non-membership proof.

An accumulator which only accumulates a finite set of values without allowing addition of new values or deletions of existing values is called a static accumulator. An accumulator which allows additions and deletions of values is called a dynamic accumulator. A universal accumulator is a dynamic accumulator which allows both membership and non-membership proofs. Both RSA based and Elliptic Curve based accumulators have both static and dynamic constructions. The RSA accumulator will be explored here.

Accumulators are related to a number of other cryptographic data structures like Merkle Trees and Bloom Filters. The primary difference between Merkle Trees and Accumulators is that in the former the position of the element is important whereas in the latter the order is irrelevant. The primary difference between Bloom Filters and Accumulators is that while both can say for certain that a value is not in a set, only the Accumulator can say for certain that a value is in a set due to their being false positives with Bloom Filters.

## Definitions
###One-way hash functions
A one-way hash function family \(\{\mathcal{H}_\lambda\}_{\lambda\in N}\) is defined such that
\[
\ \mathcal{H}_\lambda = \{\mathit{h}_k : X_k \times Y_k \rightarrow Z_k\}; \lambda \in N, \mathit{h}_k \in \mathcal{H}_\lambda\
\]
\[
\begin{multline}
\shoveright
\begin{aligned}
(1)
\end{aligned}
\end{multline}
\]

and is assumed to also possess the properties of strong one-way hash functions.

###Quasi-commutative function
A quasi-commutative function is defined such that for
\(\mathit{f}:X \times Y \rightarrow X\)
\[
\ (\forall x \in X)\;(\forall y_1,y_2 \in Y)\;[\;\mathit{f}\;(\mathit{f\;(x,y_1),y_2}) = \mathit{f}\;(\mathit{f\;(x,y_2),y_1})\;]
\]
\[
\begin{multline}
\shoveright
\begin{aligned}
(2)
\end{aligned}
\end{multline}
\]

###One-way Accumulator
Should a quasi-commutative function also be a one-way hash function, then it is a one-way accumulator.

###Accumulator Scheme
For a static accumulator, the accumulator scheme is an ordered list of four algorithms.

* Gen is the key generation algorithm. Gen takes as input a security parameter \(1^\lambda\) and an accumulation threshold (\(\mathcal{N}\)) and returns an accumulator key (\(\mathcal{k}\)) from the key space
\(\mathcal{K}_{\lambda,N}\)

* Eval is the evaluation algorithm used to accumulate a set
\(\mathcal{L} = \{y_1,..,y_{n\text{'}}\} \;\text{of}\;\mathcal{N}^\text{'}\leq \;\mathcal{N}\) from domain \(Y_k\), where \(\mathcal{k}\in\mathcal{K}_{\lambda,N}\). It takes (\(\mathcal{k}_\lambda,\mathcal{L}\)) and returns (\(\mathcal{z}\in Z_k,aux\)\), where \(\mathcal{z}\) is the accumulator. Note that while the auxiliary information may differ, the accumulated value will be the same on the same input.

* Wit is the witness extraction algorithm. It takes an accumulator key \(k\in\mathcal{K}_{\lambda,N}\), a value \(y_i \in Y_k\), the auxiliary information generated by Eval, as well as the accumulator \(\mathcal{z}\). It returns \(\overline{w_i}\) which proves \(\mathcal{y_i}\) was accumulated within \(\mathcal{z}\), otherwise it returns \(\bot\).

* Ver is the verification algorithm. It's input is the accumulator key \(\mathcal{k}\), a value \(\mathcal{y_i}\), a witness \(\overline{w_i}\) and the accumulator \(\mathcal{z}\). It returns a boolean value according to whether the witness is a valid proof of \(\mathcal{y_i}\) being accumulated within \(\mathcal{z}\), namely \(\mathcal{h_k(w_i,y_i)}\stackrel{?}{=}\mathcal{z}\).

For a dynamic accumulator, it is the previous ordered list of four algorithms plus an additional three.

* Add is the element addition algorithm. It takes an accumulator key \(\mathcal{k}\), a value \(\mathcal{z}\in Z_k\) (the accumulation of \(\mathcal{L}\) of less than \(\mathcal{N}\) elements in \(Y_k\) ) and another value \(y'\in Y_k\). It returns a new accumulator \(\mathcal{z'}\) corresponding to \(\mathcal{L}\cup \{y'\}\), a witness \(\overline{\mathcal{w'}}\in W_k\) and some auxiliary information (\(\mathcal{aux_{Add}}\)).

* Del is the element deletion algorithm. It takes an accumulator key \(\mathcal{k}\), a value \(\mathcal{z}\in Z\) (the accumulation of \(\mathcal{L}\) of elements in \(Y_k\) ) and an element \(\mathcal{y'}\in \mathcal{L}\). It returns a new accumulator \(\mathcal{z'}\) corresponding to \(\mathcal{L}\backslash\{y'\}\) and some auxiliary information (\(\mathcal{aux_{Del}}\)).

* Upd is the witness update algorithm. It takes an accumulator key (\(\mathcal{k}\)), a value \(\mathcal{y}\in Y_k\), a witness \(\overline{\mathcal{w}}\in W_k\), an operation \(\mathcal{b}\) (either Add or Del) and the auxiliary data \(\mathcal{aux_{op}}\) corresponding to \(\mathcal{b}\). It returns an updates witness \(\overline{\mathcal{w'}}\) that proves the presence of \(\mathcal{y}\) within the updated accumulator \(\mathcal{z'}\).

These are assumed to be constructed to be both trapdoor-less and collision-free accumulator schemes.

###The RSA Accumulator

The RSA accumulator works on modular exponentiation.

We have a random generator \(\mathcal{g}\). An RSA group with modulus \(\mathcal{N}\). A set \(\mathcal{S}\). A function \(\mathcal{HashPrime}\) which hashes values into odd primes. \(\mathcal{S_P}\) is the set of hashing all elements of the set \(\mathcal{S}\) and \(\mathcal{P_s}\) is the product of all primes in \(\mathcal{S_P}\).

The value of the accumulator (the commitment to \(\mathcal{S}\)) is then:
\[
\mathcal{z} = \mathcal{g}^{P_s} \!\!\!\!\!\!\mod \mathcal{N}
\]

######Membership Proof
For any \(\mathcal{x}\) element in \(\mathcal{S}\) and \(\mathcal{p_x}\) is \(\mathcal{HashPrime(x)}\) for the corresponding element in \(\mathcal{P_s}\).
 The membership proof of element \(\mathcal{x}\) (the witness \(\mathcal{\overline{w_x}}\)) is given by
\[
\mathcal{\overline{w_x}} = \mathcal{g}^{P_s/P_x} \!\!\!\!\!\!\mod \mathcal{N}
\]

Membership of \(\mathcal{x}\) can be verified against commitment \(\mathcal{z}\) by

\[
\mathcal{\overline{w_x}}^{P_x} \!\!\!\!\!\!\mod \mathcal{N} = (\mathcal{g}^{P_s/P_x})^{P_x} \!\!\!\!\!\!\mod \mathcal{N} = \mathcal{g}^{P_s} \!\!\!\!\!\!\mod \mathcal{N} = \mathcal{z}
\]

######Non-Membership Proof
If we calculate the Bezout coefficients \(\mathcal{a,b}\) such that \(\mathcal{aP_y} + \mathcal{bP_s}=1\) the non-membership witness \(\mathcal{\overline{U_y}}\) for \(\mathcal{y}\) is pair \((\mathcal{g^a,b})\).

To verify \(\mathcal{y}\) is not part of the accumulated set, using \(\mathcal{\overline{U_y}} = (\mathcal{d},\mathcal{b})\), check that
\[
\mathcal{d}^{P_y}\mathcal{z^b} = \mathcal{g}^{a{P_y}}\mathcal{g^{b{P_s}}} =  
\mathcal{g^{aP_y+bP_s}} = \mathcal{g}
\]

######Adding an element
Adding \(\mathcal{x}\) to the accumulator \(\mathcal{z}\) with \(\mathcal{\overline{w_x}}\) being the current witness for set \(\mathcal{S}\) then
\[
\mathcal{\overline{{W_x}'}} = \mathcal{\overline{W_x}}^\mathcal{P_x} \!\!\!\!\!\!\mod \mathcal{N}
\]
\[
\mathcal{{z}'} = \mathcal{z}^\mathcal{P_x} \!\!\!\!\!\!\mod \mathcal{N}
\]
Such that
\[
\mathcal{\overline{{W_x}'}} \!\!\!\!\!\!\mod \mathcal{N} = \mathcal{W_x}^{P_x} \!\!\!\!\!\!\mod \mathcal{N} = \mathcal{z}^{P_x} \!\!\!\!\!\!\mod \mathcal{N} = \mathcal{{z}'}
\]

######Removing an element
Removing \(\mathcal{x}\) from the accumulator \(\mathcal{z}\) with \(\mathcal{\overline{w_x}}\) being the current witness for set \(\mathcal{S}\) then
\[
\mathcal{\overline{{W_x}'}} = \mathcal{\overline{W_x}}^\mathcal{1/P_x} \!\!\!\!\!\!\mod \mathcal{N}
\]
\[
\mathcal{{z}'} = \mathcal{z}^\mathcal{1/P_x} \!\!\!\!\!\!\mod \mathcal{N}
\]
Such that
\[
\mathcal{\overline{{W_x}'}} \!\!\!\!\!\!\mod \mathcal{N} = \mathcal{W_x}^{1/P_x} \!\!\!\!\!\!\mod \mathcal{N} = \mathcal{z}^{1/P_x} \!\!\!\!\!\!\mod \mathcal{N} = \mathcal{{z}'}
\]

## References
[Cryptographic Accumulators:  Definitions,Constructions and Applications](https://cs.nyu.edu/~fazio/research/publications/accumulators.pdf) Date accessed: 2019&#8209;25&#8209;09.

[Introduction to SPV, Merkle Trees and Bloom Filters](https://tlu.tarilabs.com/protocols/merkle-trees-and-spv-1/sources/PITCHME.link.html) Date accessed: 2019&#8209;25&#8209;09.


## Contributors
- <https://github.com/StriderDM>
